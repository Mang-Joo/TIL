# InnoDB 스토리지 엔진 아키텍처

InnoDB는 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

## 프라이머리 키에 의한 클러스터링

기본적으로 PK를 기준으로 클러스터링 되어 저장된다. 즉, PK 값의 순서대로 디스크에 저장되며, 모든 세컨더리 인덱스는 레코드의 주소 대신 PK를 논리적인 주소로 사양한다.\
PK가 클러스터링 인덱스이기 때문에 PK를 이용한 레인지 스캔은 상당히 빨리 처리할 수 있다.

결과적으로 쿼리의 실행 계획에서 PK는 기본적으로 비중이 높게 설정된다.

## 외래 키 지원

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 주의해야 한다.

또한 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다.\
이런 경우에는 시스템 변수를 통해 외래 키 체크 작업을 멈추고 동작 시킬 수 있다.

## MVCC(Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 기능이며, 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.

InnoDB는 언두 로그를 이용해 이 기능을 구현한다.\
여기서 멀티 버전의 의미는 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 뜻이다.

다음 그림은 테이블에 한 건의 레코드를 INSERT 한 후 UPDATE 해서 발생하는 변경 작업 및 절차다.

<img src="../../../.gitbook/assets/file.excalidraw.svg" alt="INSERT 상태" class="gitbook-drawing">

<img src="../../../.gitbook/assets/file.excalidraw (3).svg" alt="UPDATE 상태" class="gitbook-drawing">

> 데이터 파일이 ???인 이유는 InnoDB 버퍼 풀의 변경 내용은 백그라운드 스레드에 의해서 기록되기 때문에 변경 내용이 언제 기록되는지는 알 수 없다.

UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이 버퍼 풀은 새로운 값으로 업데이트된다.\
아직 `COMMIT` 이 되지 않은 상태에서 조회를 하게 된다면 어떻게 될까?

격리 수준에 따라 다른데 `READ_COMMITED` 나 그 이상의 격리 수준일 경우는 커밋 되지 않았기 때문에 변경되기 이전에 값이 있는 언두 로그 영역의 데이터를 반환한다.

COMMIT을 실행하면 새로운 데이터로 변경되고 버퍼 풀은 지금의 상태를 영구적인 데이터로 만들어 버린다.\
ROLLBACK을 실행하면 언두 영역의 데이터를 다시 버퍼 풀로 복구하고 언두 영역의 내용을 삭제해 버린다.

하지만 커밋이 된다고 바로 백업 데이터가 삭제되는 것은 아니고, 필요로 하는 트랜잭션이 없을 때 삭제된다.
