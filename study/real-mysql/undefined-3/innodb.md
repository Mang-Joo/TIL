# InnoDB 스토리지 엔진 잠금

스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.\
레코드 기반의 잠금 방식 때문에 뛰어난 동시성 처리를 제공할 수 있다.

## InnoDB 스토리지 엔진의 잠금

레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없다.\
또한 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

## 레코드 락

레코드 자체만을 잠그는 것을 레코드 락 이라고 한다. 한 가지 중요한 것은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.\
인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명한 넥스트 키 락 또는 갭 락을 사용하지만 PK 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

즉 레코드 자체만을 잠구는 것은 아니고, 인덱스를 잠구는 것이다.

## 갭 락

갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.\
갭 락의 역할을 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다.

## 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.\
넥스트 키 락과 갭 락으로 데드락이 발생하거나 다른 트랜잭션을 기다리게 하는 일이 자주 발생하기 때문에 사용하지 않는것이 좋다.

## 자동 증가 락

자동 증가하는 숫자 값을 추출(채번)하기 위해 AUTO\_INCREMENT라는 컬럼 속성을 제공한다.\
테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.\
이를 위해 내부적으로 자동증가 락이라고 하는 테이블 수준의 잠금을 사용한다.

INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE에는 걸리지 않는다.

## 인덱스와 잠금

잠금과 인덱스는 상당히 중요한 연관관계가 있다.\
레코드 락은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.\
변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

```sql
SELECT COUNT(*) FROM employees WHERE first_name='Georgi';
# 253

SELECT COUNT(*) FROM employees WHERE first_name='Georgi' AND last_name='Klassen';
# 1

UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```

UPDATE 문장이 실행되면 1건의 레코드가 업데이트 될 것이다.\
하지만 이 1건의 업데이트를 위해 몇 개의 레코드에 락을 걸어야 할까?\
인덱스를 이용할 수 있는 조건은 first\_name='Georgi'이며, last\_name은 인덱스가 없기 때문에 first\_name='Georgi'인 레코드 253건의 레코드가 모두 잠긴다.

적절히 인덱스가 준비되어 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 기다려야 하는 상황이 발생할 것이다.

**때문에 인덱스 설계는 매우 중요하다.**

