# 모델과 구현의 연계

## Model-DRIVEN DESIGN (모델 주도 설계)

코드와 그것의 기반이 되는 모델이 긴밀하게 연결되면 코드에 의미가 부여되고 모델과 코드가 서로 대응하게 된다.

도메인 모델은 전혀 없고 기능만 차례로 구현하기 위해 코드를 작성하는 프로젝트는 지식 탐구와 의사소통의 이점을 거의 살리지 못한다.\
이러한 전형적인 코드는 내가 처음 공부할 때 작성했던 코드와 같다.

다음은 그 일부분이다.

```java
@RequestMapping("/searchId")
public String SearchId(Model model, UserDto dto) {

    List<UserDto> list = biz.SelectUser(dto);

    model.addAttribute("userList", list);

    return "admin/userManage";
}
```

해당 코드의 모델은 dto만 있고 그 비즈니스 로직엔 db와 커넥션 맺는 부분 밖에 없다.\
User가 해야 할 일을 DB가 하거나, 애플리케이션 레이어쪽에서 해결하게 되는 것이다.\
User에 대한 책임을 다른 클래스가 가져가 더욱 복잡한 코드가 작성되고, 코드는 여기 저기 흩어지며 유지보수가 불가능에 가까운 상태가 될 것이다.

설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없다.\
실제로 설계가 변경되면 유지보수가 불가능해진다.\
위에 작성 되어 있는 코드를 유지보수 하려면 DB를 고쳐야 한다.\
하지만 모르는 사람이 봤을 때 저 부분에서 무엇을 고쳐야 할 지 알 수 있을까?\
이러한 이유로 해당 코드는 유지보수가 불가능에 가까워진다.

**설계할 때는 도메인 모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게 해야한다.**

## HANDS-ON MODELER (실천적 모델러)

책에서 나오는 내용 중 와닿았던 말이다.

코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나, 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관해진다. 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킬 것이다.

해당 글을 보고 느낀 점은 '그냥 코드가 돌아가게 작성만 하면 됐지' 라고 생각하는 개발자가 너무 많다는 것이었다.\
실제로 모델은 Dto 그 이상도 이하도 아니라고 생각하는 사람도 많고, 서비스 레이어에 모든 코드가 있고 쿼리로 모든 문제를 해결하려는 사람들도 많다. 그렇게 작성하게 된다는 것은 유지보수는 커녕 코드를 파악하는 것도 굉장한 시간이 걸릴 것이다.

도메인 주도 설계는 모델을 동작하게 만들어 애플리케이션의 문제를 해결하는 것이다.\
지식탐구와 의사소통을 통해 꾸준히 모델을 업데이트 해가며 좋은 코드(?)를 작성하고 싶다.

