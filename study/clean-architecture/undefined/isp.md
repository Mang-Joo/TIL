---
description: Interface Segregation Principle
---

# ISP 인터페이스 분리 원칙



### ISP

인터페이스 분리 원칙은 단일 책임 원칙과 연결된다.

다음 1.1 그림을 한번 보자.

<img src="../../../.gitbook/assets/file.drawing (3).svg" alt="1.1" class="gitbook-drawing">

다수의 사용자가 OPS 클래스의 오퍼레이션을 사용한다.\
User1은 op1, User2는 op2, User3는 op3만을 사용한다고 가정해보자. &#x20;

이런 경우 User1은 op1만 사용하지만, op2와 op3를 의존하게 된다.\
또한 이러한 의존성으로 인해 OPS클래스에서 op2나 op3가 수정 되더라도 User1도 다시 컴파일을 해야하는 상황이 발생한다.

이러한 문제를 해결하기 위해 OPS를 인터페이스 단위로 분리하여 해결할 수 있다.

다음 1.2 그림을 다시 보자

<img src="../../../.gitbook/assets/file.drawing (1).svg" alt="1.2" class="gitbook-drawing">

이번 User1의 코드는 U1Ops와 op1에는 의존하지만 OPS에는 의존하지 않는다.\
따라서 OPS에서 발생한 변경이 User1과는 전혀 관계없는 변경이라면, User1을 다시 컴파일 하는 상황은 초래되지 않게 된다.

### ISP와 아키텍처

ISP를 사용하는 근본적인 동기를 보면, 잠재되어 있는 더 깊은 우려사항을 볼 수 있다.\
&#x20;일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.\
&#x20;예를들어 S 시스템 구축을 하는데 F라는 프레임워크를 의존하고 F라는 프레임워크는 D 데이터베이스를 반드시 사용하도록 만들었다고 가정하면 다음과 같은 그림이 나온다.

<img src="../../../.gitbook/assets/file.drawing (2) (1).svg" alt="1.3" class="gitbook-drawing">

F에서는 불필요한 기능, S와는 전혀 관계없는 기능이 D에 포함된다고 가정하였을 때, D가 수정되면 S까지 재배포를 해야하는 상황이 발생할 수 있다.

### 결론

여기서 알아야 할 것은 불필요한 것을 의존하면 예상하지 못할 문제에 빠질 수 있다는 것이다.

OPS -> Service라고 가정하였을 때 크게 포괄하는 인터페이스보다는 잘게 나누어진 인터페이스가 훨씬 좋다.

SRP를 인터페이스에 적용시키면 좀 더 잘게 나누어진 인터페이스가 나올 것이다.
