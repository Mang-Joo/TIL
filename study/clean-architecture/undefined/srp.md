---
description: Single Responsibility Principle
---

# SRP(단일 책임 원칙)

### 우발적 중복

SRP는 단일 책임 원칙이라고 불린다.\
프로그래머들은 이 원칙을 듣는다면 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아드리게 된다.

단, 하나의 일만 해야한다는 것은 함수가 반드시 하나의 일만 해야 한다는 원칙이다.

변경을 요청하는 사람들을 액터(Actor)라고 부를 때 SRP란 `하나의 모듈은 하나의 액터에 대해서만 책임져야 한다.`라는 의미로 해석된다.

단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 `응집성`이다.

하나의 유스케이스당 하나의 클래스가 나와야 하며, 유스케이스 안에서도 단일책임 원칙이 이어져야 한다.

Employee라는 클래스 안에 `calculatePay()`, `reportHours()`, `save()` 가진다.

이 클래스는 세 가지 메서드가 서로 매우 다른 세명의 액터를 책임지고 있기 때문에 SRP를 위반하게 되는 것이다.

* `calculatePay()` 메서드는 회계팀에서 사용한다.
* `reportHours()` 메서드는 인사팀에서 사용한다.
* `save()` 메서드는 DBA가 사용한다.

이러한 상황일 때 `calculatePay()`와 `reportHours()`가 서로 공유하는 private 메서드가 있다고 가정할 때, 한쪽만 수정해야 하는 경우 버그가 발생할 수 있다.\
실제로 테스트를 진행하더라도 테스트 자체는 성공할테지만, 데이터가 변하게 되어 한쪽에서는 큰 문제가 발생할 수 있다.

우리는 이러한 문제가 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.

<mark style="color:orange;">**SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.**</mark>

### 해결책

모두가 각기 다른 클래스로 이동 시키는 방식이다.

3개의 클래스로 나누어 각각 클래스를 가지고, 각각의 클래스가 서로를 모른다면 '중복' 문제를 피할 수 있다.\
또한 이 클래스들을 추적해야 하는 불편함이 있다. 이러한 불편함을 해결하기 위해 퍼사드패턴을 사용하게 된다.

### 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.&#x20;
