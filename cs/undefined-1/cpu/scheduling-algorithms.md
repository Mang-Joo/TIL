# 스케줄링 알고리즘(Scheduling Algorithms)

CPU 스케줄링은 어느 프로세스에 CPU 코어를 할당할 것 인지를 결정하는 문제를 다룬다.

한 개의 처리 코어를 가진 CPU는 한 번에 하나의 프로세스만 실행할 수 있다.

여기서는 한 개의 코어에서 얼마나 최적의 프로세스를 처리할 수 있느냐를 선택하기 위한 알고리즘들을 설명한다.

#### 선입 선처리 스케줄링(First-Come, First-Served Scheduling)

가장 간단한 알고리즘은 `선입 선처리(FCFS)` 알고리즘이다. CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받게 된다. 구현 자체는 FIFO 큐로 관리하도록 한다. 하지만 이 알고리즘은 평균대기 시간이 종종 매우 길어질 수 있다. 예를 들어 P1은 24, P2는 3, P3는 3초가 걸린다고 했을 때 0-24 24-27 27-30 으로 차트가 나올 것이다. 그렇다면 p2의 대기시간은 24초, p3의 대기시간은 27초 이기 때문에 (0 + 24 + 27) / 3을 하면 17초가 나온다. 그러나 P2 -> P3 -> P1 순으로 도착할 경우 평균 대기시간은 3초가 나오게 된다. 즉 일반적으로 FCFS의 평균 대기시간은 최소가 아니게 된다. 또한 이 알고리즘의 단점으로는 I/O 프로세스를 실행 할 경우 CPU 버스트가 굉장히 짧지만, CPU 중심 프로세스는 좀 더 길게 기다려야 될 수 있으므로 I/O프로세스 실행 후 그 다음 실행까지 얼만큼의 대기시간이 생길지 모른다는 것이 단점이 될 수 있다. 이러한 것처럼 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 **호위 효과(convoy effect)** 라고 한다. 이 알고리즘은 비 선점형 알고리즘(Nonepreemptive Algorithm)이다. CPU가 한 프로세스에 할당되면, CPU를 방출할 때까지 CPU를 점유한다.

#### 최단 작업 우선 스케줄링 (Shortest Job First Scheduling)

최단 작업 우선(shortest-job-first, **SJF**) 알고리즘은 말 그대로 CPU 이용 시간이 가장 적은 것들을 맨 앞으로 보내어 순서대로 진행하게 된다. 또한 동일한 시간을 가진 프로세스는 **FCFS**를 적용하여 먼저 들어온 것부터 처리하도록 실행한다. SJF 알고리즘은 최소의 평균 대기 시간을 가진다는 점에서는 최적임을 증명할 수 있다. 이 알고리즘은 최적이긴 하지만, 다음 CPU 이용 시간을 알 방법이 없기 때문에 **CPU 스케줄링 수준에서는 구현할 수 없다.**

이 알고리즘은 선점형이거나 비 선점형일 수 있다. 새로운 프로세스가 준비 큐에 도착하면 **선택이 발생**한다. 새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 이용 시간을 가질 수도 있다. 선점형 SJF 알고리즘은 현재 실행하는 프로세스를 선점할 것이고, 비 선점형 SJF 알고리즘은 현재 실행하고 있는 프로세스가 자신의 CPU 이용을 끝내도록 허용한다.

#### 라운드 로빈 스케줄링(Round-Robin Scheduling)

`라운드 로빈(RR)` 알고리즘은 선입 선처리 알고리즘과 유사하지만, 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다. 시간 할당량 이라고 하는 작은 단위의 시간을 정의한다. 준비 큐는 원형 큐로 동작하며, CPU 스케줄러는 한 번에 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다. 다시 정리하면, CPU 스케줄러는 준비 큐에서 첫 번째 프로세스를 선택해 한 번의 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 `dispatch` 한다. 이렇게 하면, 두 가지 경우가 생긴다.

1. CPU 이용 시간이 시간 할당량보다 작을 경우.
2. CPU 이용 시간이 시간 할당량보다 클 경우. 첫 번째의 경우, 프로세스가 자발적으로 CPU를 방출시킨다. 두 번째의 경우, 인터럽트가 발생하며 문맥 교환이 일어나고 실행하던 프로세스는 준비 큐의 꼬리에 넣어진다.

예시를 들어보면, 시간 할당량은 3초로 두고 P1은 30초, P2는 3초, P3는 6초라고 했을 경우 다음과 같은 그림을 볼 수 있다. !\[\[Round-Robin-GanttChart.excalidraw]]

RR 알고리즘은 언뜻 보기엔 최적의 알고리즘이라고 생각이 들 수 있다. 하지만 RR 알고리즘은 시간 할당량의 설정 값에 따라 성능이 바뀌기 때문에 그것을 잘 고려해야 한다. 만약 시간 할당량을 12시간으로 했을 경우, 실질적으로 실행될 때 이 알고리즘은 `FCFS`와 다를 것이 없을 것이다. 그렇다고 1ms로 했을 경우 문맥 교환이 너무 자주 일어나게 되면서 오히려 시간 낭비가 더 많게 될 것이다.

그렇기 때문에 RR 알고리즘에서 가장 중요한 것은 시간 할당량의 설정 값이라고 봐도 될 것 같다.

#### 우선순위 스케줄링(Priority Scheduling)

앞에서 얘기한 `SJF 알고리즘`은 `우선순위 스케줄링` 알고리즘의 특별한 경우이다. 우선순위 알고리즘은 말 그대로 우선순위가 높은 순서대로 처리하겠다는 알고리즘이며, 이 우선순위는 내부적으로나 외부적으로 정해질 수 있다.

내부적으로 정의된 우선순위는 프로세스의 우선순위를 계산하기 위해 어떤 측정 가능한 양들을 사용한다. ex) 시간 제한, 메모리 요구, 평균 I/O, 평균 CPU에 대한 비율 등이 우선순위 계산에 사용된다.

외부적으로 정의된 우선순위는 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 유형과 양 등등 운영체제 외부의 기준에 의해 결정된다. 즉, 사용자가 정하는 우선순위라고 봐도 무방할 것 같다.

우선순위 스케줄링은 새로 도착한 프로세스의 우선순위를 현재 실행 중인 우선순위와 비교하여 우선순위가 더 높은 프로세스를 실행하게 된다. 때문에 이 알고리즘은 선점이면서 비 선점이 될 수 있다.

이 알고리즘의 주요 문제는 `indefinite blocking(무한 블로킹)` 또는 `starvation(기아 상태)`이다.

우선 순위가 가장 낮은 프로세스들은 높은 우선순위에 계속 밀리기 때문에 결국 실행 되지 못하는 상태를 의미한다.

#### 다단계 피드백 큐 스케줄링(Multilevel Queue Scheduling)

다단계 피드백 큐 스케줄링 알고리즘에서는 **프로세스가 큐들 사이를 이동하는 것을 허용**한다.

이러한 것을 허용하기 때문에 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동시키며 기아 상태를 예방한다.

이 스케줄링의 동작 방식은 처음에 큐 0의 모든 프로세스를 실행시킨다. 그 후에 큐 0이 **비어있을 때** 큐 1에 있는 프로세스들을 실행시킨다. 마찬가지로 큐 0과 큐 1이 비어있을 때 큐 2를 실행시킨다.

다단계 피드백 큐 스케줄러의 정의에 의하면 이 스케줄링 알고리즘은 가장 일반적인 CPU 스케줄링 알고리즘이다. 하지만 가장 좋은 스케줄러로 동작하기 위해서는 모든 매개변수들의 값을 선정하는 특정 방법이 필요하기 때문에 또한 가장 복잡한 알고리즘이기도 하다.
