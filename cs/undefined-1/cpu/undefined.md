# 기본 개념

코어가 하나인 시스템에서는 한순간에 오직 하나의 프로세스만이 실행될 수 있다. 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.

또한 하나의 프로세스는, 전형적으로 어떤 I/O 요청이 완료되기를 기다려야만 할 때까지 실행된다. 이렇게 되면, 단일 코어 시스템에서 CPU는 그저 놀고 있게 된다. CPU는 프로세스를 할당 받고 대기해야 할 경우엔 다시 프로세스를 반납하며 새로운 프로세스를 다시 할당 받는다. 이렇게 CPU가 프로세스를 할당 받고 반납 하고 반복하는 이 개념을 `CPU Scheduling`이라고 한다.

이러한 스케쥴링은 운영체제의 기본적인 기능이며, 모든 컴퓨터 자원들은 사용되기 전에 스케줄 된다.

### CPU-I/O 버스트 사이클 (CPU-I/O Burst Cycle)

프로세스 실행은 CPU 실행과 I/O대기의 **사이클**로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다. 프로세스 실행은 CPU 버스트(burst)로 시작되며, 뒤이어 I/O 버스트가 발생하고, 그 뒤에 또 CPU 버스트가 발생하며, 또 다른 I/O 버스트가 발생한다.

> CPU burst, I/O burst란?
>
> * CPU burst : CPU 명령을 실행 하는 것
> * I/O burst : I/O 요청 후 기다리는 것

### CPU 스케쥴러

CPU가 유휴 상태가 될 때마다, 운영체제는 준비 큐에 있는 프로세스 중에서 하나를 선택하여 실행한다. 선택 절차는 CPU 스케쥴러에 의해 수행되며, 스케쥴러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여 CPU를 할당한다. 준비 큐는 반드시 FIFO 방식의 큐가 아니어도 되며 트리, 링크드 리스트 등으로 구현할 수 있다. 큐에 있는 `Data`들은 일반적으로 프로세스들의 \*\*프로세스 제어 블록(PCB)\*\*들이다.

### 선점 및 비선점 스케쥴링

CPU Scheduling의 결정은 4가지 상황에서 발생할 수 있다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환 될 때 ex) I/O요청이나 자식 프로세스 종료를 기다리는 wait 상태
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환 될 때 ex) 인터럽트 발생
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환 될 때 ex) I/O 종료 시
4. 프로세스가 종료할 때

1번과 4번의 경우는, 선택의 여지가 없다. **실행을 위해 새로운 프로세스가 반드시 선택**되어야 한다. 즉, 이 상태는 CPU가 놀고 있는 상태이기 때문에 반드시 선택되어야 한다.

하지만 2번과 3번의 경우는 선택의 여지가 있다. 인터럽트가 발생하거나, I/O가 종료 될 때는 현재 프로세스를 계속 실행할 것인지, 새로 인터럽트가 발생한 프로세스를 실행시킬 것인지에 대해서 선택할 수 있기 때문에 선택의 여지가 있다고 한다.

1번과 4번처럼 선택의 여지가 없이 스케쥴링이 발생할 경우 비선점(nonpreemptive) Scheduling이라고 한다. 또한 2번과 3번처럼 선택의 여지가 있다면, 선점(preemptive) Scheduling이라고 한다. 처음에 이 내용을 보았을 때 선점 스케줄링 이라고 하면, 선점하고 있으니 뺏기지 않아야 된다고 생각했는데, 관점을 바꿔서 내가 바꿔야 할 프로세스라고 기준을 잡고 보아야 할 것 같다. 선점 스케줄링은 내가 선점할 수 있는 프로세스를 스케줄링 한다.

Windows, Linux, MacOS를 포함하여 대부분의 최신 운영체제들은 Preemptive Scheduling(선점 스케줄링)을 사용한다. 하지만 Preemptive Scheduling은 데이터가 다수의 프로세스에 의해 공유 될 때 경쟁 조건을 초래할 수 있다. 프로세스가 자료구조를 공유 하는 경우 `A 프로세스`가 자료를 갱신하는 동안 선점 되어 `B 프로세스`가 실행 될 수 있다. 이 때 `B 프로세스`가 데이터를 읽으려고 할 때, **데이터의 일관성은 이미 깨진 상태**가 된다.

`비선점형 커널`은 문맥 교환을 하기 전에 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 **블로킹(Blocking)** 되기를 기다린다. 이러한 커널 방식은 실시간 컴퓨팅을 지원하기엔 좋은 모델이 아니라고 한다.

`선점형 커널`에는 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해 mutex Lock과 같은 기법을 사용해야 한다. 다수 프로세스가 병행으로 접근할 수 없도록 그 진입점에서 인터럽트를 불능화하고, 출구에서 인터럽트를 다시 가능화한다. 하지만 이런 형태가 자주 발생하게 되면 그만큼 느려진다는 것이기 때문에 이런 상황은 최대한 줄여야 한다.

### 디스패처(Dispatcher)

디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈이며 다음 세 가지 작업을 포함한다.

* 한 프로세스에서 다른 프로세스 **문맥을 교환**하는 일
* **사용자 모드로 전환**하는 일
* 프로그램을 다시 시작하기 위해 사용자 프로그램의 **적절한 위치로 이동**하는 일

`Dispatcher`는 모든 프로세스의 **문맥 교환 시 호출**되므로, 최고로 빨리 수행되어야 한다. 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데 까지 걸리는 시간을 `디스패치 지연(Dispatch latency)` 이라고 부른다.

문맥 교환에는 **자발적 문맥 교환**과 **비자발적 문맥 교환**이 있다.

**자발적 문맥 교환**

자발적 문맥 교환이란 현재 사용 불가능한 자원을 요청했기 때문에 프로세스가 CPU 제어를 포기한 경우 발생한다.

**비자발적 문맥 교환**

타임 슬라이스가 만료되거나, 우선순위가 더 높은 프로세스에 의해 선점 된 경우와 같이 CPU를 빼앗겼을 때 발생한다.
