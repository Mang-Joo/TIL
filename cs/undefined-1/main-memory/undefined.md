# 배경

### 9.1.1 Basic Hardware(기본 하드웨어)

`메인 메모리`와 각 처리코어에 내장된 `레지스터`들은 CPU가 직접 접근할 수 있는 **유일한** 범용 저장장치이다. 기계 명령어들은 메모리 주소만을 인수로 취하고, 디스크의 주소를 인수로 취하지 않는다. 따라서 모든 실행되는 `명령어`와 `데이터`들은 CPU가 직접적으로 접근할 수 있는 **메인 메모리와 레지스터에 있어야한다.**

먼저 각각의 프로세스는 독립된 메모리 공간을 가지도록 보장해야 한다. 개별적인 프로세스별 메모리 공간은 서로를 보호하고 병행 실행을 위해 여러 프로세스가 메모리에 적재되게 하는 것이 필수적이다.

기준 레지스터는 가장 작은 합법적인 물리 메모리 주소의 값을 저장하고, 상한 레지스터는 주어진 영역의 크기를 저장한다.

여기서 이 설명들이 나에겐 전혀 와닿지가 않았다.

검색 해본 결과는 다음과 같다.

* Base register
  * Used to store address of current memory locations during execution.
  * 실행 중인 현재 메모리 위치의 주소를 저장하는데 사용한다. 즉 프로그램이 실행될 때 메모리 주소를 할당받게 되는데 그 메모리 주소의 시작주소를 의미한다.
* Limit register
  * Specifies the size of the range.
  * 범위의 크기를 지정한다. 즉 메모리의 범위를 나타낸다.

예를 들어 A 프로그램이 메모리에 적재될 때 `Base register`가 `10_000` 이고 `Limit register`가 `5_000` 이라면 해당 메모리는 `10_000~15_000` 까지 사용할 수 있다.

### 9.1.2 주소의 할당

프로그램은 이진 실행 파일 형태로 디스크에 저장되어 있다. 실행하려면 프로그램을 `memory`로 가져와서 **프로세스 문맥** 내에 배치해야 한다. 이 시점에 가용한 CPU에서 실행할 수 있게 된다.

프로세스가 종료되면 다른 프로세스에서 사용하기 위해 메모리는 회수된다.

대부분의 시스템은 사용자 프로세스가 메모리 내 어느 부분으로도 올라올 수 있도록 지원하고 있다.

원시 프로그램에서 주소는 숫자가 아닌 **심볼 형태로 표현**된다. 컴파일러는 이 심볼 주소를 `Relocatable Address`(재배치 가능 주소)로 바인딩 시키고, 다음에 Linker나 Loader가 `Relocatable Address`를 `Absolute Address`(절대 주소)로 바인딩 시킨다.

> 링커
>
> 프로그램의 여러 개의 오브젝트 파일을 합치고, 라이브러리를 추가하여 최종적으로 실행 가능한 프로그램을 생성하는 역할

메모리 주소 공간에서 명령어와 데이터의 바인딩은 바인딩이 이루어지는 시점에 따라 구분된다.

#### Compile Time(컴파일 시간)

바인딩 : 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 `Absolute code` 를 생성할 수 있다. 따라서 프로세스가 R번지로부터 시작하는 것을 미리 알 수 있으면 그 위치에서 시작해 나간다. 그러나 만일 위치가 변경되어야 한다면 이 코드는 다시 컴파일 되어야 한다.

> Absolute code 코드가 이미 정해진 메모리 주소에 로드되는 것

\-> 프로그램 내부에서 사용하는 Logical Address가 Physical Address와 같을 때를 의미한다.

#### Load Time(적재 시간)

프로세스가 메모리 내 어디로 올라오게 될지를 컴파일 시점에 알지 못하면 컴파일러는 일단 이진 코드를 Relocatable Code로 만든다.

이 때 심볼과 진짜 번지수와의 바인딩은 프로그램이 메인 메모리로 실제로 적재되는 시간에 이루어진다. Relocatable code는 식작 주소가 변경되면 아무 때나 사용자 코드를 다시 적재하기만 하면 된다.

#### Execution Time(실행 시간)

실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트로 옮겨질 수 있다면 바인딩이 실행시간까지 허용되었다고 얘기한다.
